#!/usr/bin/env perl

# git-follow - Follow lifetime changes of a pathspec through the history of a Git repository

# Copyright (C) 2017 Nickolas Burr <nickolasburr@gmail.com>
# License under WTFPL (http://www.wtfpl.net/txt/copying/)

use 5.008;
use Getopt::Long;
use strict;
use warnings;

###
### Environment Variables
###

# optionally set default view for diffs
# shown in `git log` (defaults to inline)
my $GIT_LOG_DIFF = "--color-words";

# optionally set `--no-pager` flag option,
# and Git won't use a pager (e.g. less) to
# display commits, patch diffs, etc.
my $GIT_NO_PAGER = undef;

###
### Error Notices
###

my $repo_not_found_error   = "Not a Git repository, exiting the script";
my $invalid_pathspec_error = "Not a valid pathspec, exiting the script";
my $invalid_usage_error    = <<"END_INVALID_USAGE_ERROR";

  Usage: git follow [OPTIONS] [--] pathspec

  Flag options:

	--first,   -f                           Show the first commit where Git initiated tracking of the given pathspec.
	--func,    -F                           Show commits which affected function `funcname' in the given pathspec. See git-log(1) for details.
	--last,    -l [n]                       Show the last n commits where the given pathspec was affected. Omitting n defaults to the last commit.
	--lines,   -L n [m]                     Show commits which affected lines n and m. Omitting m defaults to EOF boundary.
	--range,   -r <startref> [<endref>]     Show commits between <startref> and <endref>. Omitting <endref> defaults to HEAD. See git-revisions(1) for details.
	--reverse, -R                           Show commits in reverse chronological order.
	--total,   -T                           Show the total number of commits for the given pathspec.

END_INVALID_USAGE_ERROR

# store length of `@ARGV`
my $argc = @ARGV;

# if `system` returns a non-zero exit status, meaning the
# current directory is not a Git repository, kill the script
!system("git rev-parse --is-inside-work-tree >/dev/null 2>&1") or die "$repo_not_found_error";

# if no arguments were given, emit an error and kill the script
$argc or die "$invalid_usage_error";

# store the last argument (which should be
# the filename the user is trying to track)
# and remove it from `@ARGV` array
my $filename = pop @ARGV;

# verify `$filename` is a valid pathspec
-e $filename or die "$invalid_pathspec_error";

# flag options passed to the script
my %flags;

# logical separator used to help differentiate
# between ambiguous flag options (and arguments),
# branch/revision/tag refs, and valid pathspecs
my $lsep = "--";

# default format to use for `git log --format` flag option
my $git_log_format = <<"END_LOG_FORMAT";
-----------------------------------------------------------
| Commit:  %C(bold cyan)%h%Creset
| Tree:    %C(bold magenta)%t%Creset
| Author:  %C(bold blue)%an%Creset %C(bold yellow)<%ae>%Creset
| Date:    %C(dim cyan)%cD%Creset %C(bold green)[%cr]%Creset
| Message: %s
-----------------------------------------------------------
END_LOG_FORMAT

# default `git log` flag options
my %git_log_flags = (
	"follow"    => "--follow",
	"format"    => "--format=$git_log_format",
	"graph"     => "--graph",
	"no-merges" => "--no-merges",
	"patch"     => "--patch-with-stat"
);

my @git_log_flag_values;

# flag options and their conflicting counterparts
my %cflags = (
	"reverse" => [
		"graph",
		"follow"
	]
);

# default argument values for flag options
my %dargs = (
	"last"  => 1,
	"lines" => 1
);

# base components of `git log` shell command, represented
# as an array to make it easier to pass to `system` builtin
my @git_log = (
	"git",
	"log"
);

# non-standard pipelines for use with non `git log` commands
my %ns_pipelines = (
	"total" => [
		"git",
		"rev-list",
		"HEAD",
		"--count"
	]
);

# if `$GIT_NO_PAGER` is defined,
# pass `--no-pager` flag to `git`
if (defined($GIT_NO_PAGER)) {
	my $git = shift @git_log;
	unshift @git_log, ($git, $GIT_NO_PAGER);
}

# determine if value is an integer
sub is_integer {
	my $num = shift;
	if (defined $num) {
		return $num =~ /^\d+$/ ? 1 : 0;
	} else {
		return 0;
	}
}

# get rev range for the given pathspec
sub get_revr {
	my $revr_start = shift;
	my $revr_end   = shift;
	# if there was no end rev range,
	# set default value to `HEAD`
	$revr_end = "HEAD" if not defined $revr_end;
	# if only an integer was given, interpolate
	# as a rev range for the current branch
	# --------------------------------------------
	# @todo: allow refname before '@{n}', either as flag option
	# argument (e.g. --branchname master --range 3 5) or passed
	# directly to `--range` (e.g. --range master 3 5)
	$revr_start = "\@{$revr_start}" if &is_integer($revr_start);
	$revr_end   = "\@{$revr_end}" if &is_integer($revr_end);
	return "$revr_start..$revr_end";
}

# format the `git log` flag with argument(s) given
sub get_format_rflag {
	my $flag = shift;
	my @args = shift;
	if ($flag eq "first") {
		return "--diff-filter=A";
	} elsif ($flag eq "func") {
		my $funcname = shift @args;
		return "-L^:$funcname:$filename";
	} elsif ($flag eq "last") {
		my $num = shift @args;
		if (!$num) {
			return "--max-count=1";
		} else {
			return "--max-count=$num";
		}
	} elsif ($flag eq "lines") {
		my @nums  = shift @args;
		my $lines = shift @nums;
		my $start = @$lines[0];
		my $end   = @$lines[1];
		if (!$end) {
			return "-L $start:$filename"
		} else {
			return "-L $start,$end:$filename";
		}
	} elsif ($flag eq "range") {
		my $revs       = shift @args;
		my $revr_start = @$revs[0];
		my $revr_end   = @$revs[1];
		return &get_revr($revr_start, $revr_end);
	} elsif ($flag eq "reverse") {
		return "--reverse";
	}
}

# map to `git log` flag options, format the
# command and pass it to `system` builtin
sub git_follow {
	my @command = ();
	# iterate through flag options and arguments (if applicable)
	while (my ($flag, $args) = each %flags) {
		my $rflag = &get_format_rflag($flag, $args);
		push @command, $rflag;
	}
	# update `@git_log_flag_values` with
	# corresponding `git log` flag options
	@git_log_flag_values = values %git_log_flags;
	# change the diff style, if applicable
	unshift @git_log_flag_values, $GIT_LOG_DIFF if defined $GIT_LOG_DIFF;
	unshift @command, @git_log, @git_log_flag_values;
	# add pathspec separator and filename
	push @command, $lsep, $filename;
	system @command;
}

# set argument value(s) for `$flag`,
# whether given to the flag or default
sub set_args {
	my $flag = shift;
	my $arg  = shift;
	if (!$arg) {
		$flags{$flag} = $dargs{$flag};
	} else {
		$flags{$flag} = $arg;
	}
}

# remove conflicting `git log` flag options so
# they're not passed to `system`, causing errors
sub rm_cflags {
	my $flag    = shift;
	my $cnflags = $cflags{$flag};
	foreach (values @$cnflags) {
		my $cnflag = shift @$cnflags;
		delete $git_log_flags{$cnflag};
	}
}

# add flag to `%git_log_flags` hash
sub set_aux_flag {
	my $nflag = shift;
	# get formatted `git log` flag
	my $rflag = &get_format_rflag($nflag);
	# remove conflicting flags
	&rm_cflags($nflag);
	# add aux flag to `%git_log_flags` hash
	$git_log_flags{$nflag} = $rflag;
}

# set non-standard pipeline that circumvents `git log`,
# which is essential for flag options like `--total` that
# shouldn't be passed to `git log` but instead use
# a completely separate command and return a value
sub set_ns_pipeline {
	my $flag = shift;
	my $base = $ns_pipelines{$flag};
	my @pipe = ();
	push @pipe, @$base, $lsep, $filename;
	system(@pipe);
	exit 0;
}

# require flag options to be case-sensitive, positionally interchangeable,
# and able to accept a range of arguments, based on the flag
Getopt::Long::Configure(
	'no_ignore_case',
	'no_auto_abbrev',
	'no_getopt_compat',
	'require_order'
);

# get flag options and arguments passed to the script
GetOptions(
	\%flags,
	'first|f',
	'func|F=s{1,1}',
	'last|l=i{0,1}' => \&set_args,
	'lines|L=i@{1,2}',
	'range|r=s@{1,2}',
	'reverse|R'     => \&set_aux_flag,
	'total|T'       => \&set_ns_pipeline
) or die "$invalid_usage_error";

# execute `git follow` command with flag options
&git_follow();

__END__

=pod

=encoding UTF-8

=head1 NAME

	git-follow - Follow lifetime changes of a pathspec through the history of a Git repository

=head1 VERSION

	version 1.0.6

=head1 SYNOPSIS

	git follow [OPTIONS] [--] pathspec

=head1 DESCRIPTION

	Follow lifetime changes of a pathspec through the history of a Git repository.

=head1 OPTIONS

	--first, -f
		Show the first commit where Git initiated tracking of the given pathspec.

	--func, -F funcname
		Show commits which affected function `funcname' in the given pathspec. See git-log(1) for details.

	--last, -l [n]
		Show the last n commits where the given pathspec was affected. Omitting n defaults to the last commit.

	--lines, -L n [m]
		Show commits which affected lines n and m. Omitting m defaults to EOF boundary.

	--range, -r <startref> [<endref>]
		Show commits between <startref> and <endref>. Omitting <endref> defaults to HEAD. See git-revisions(1) for details.

	--reverse, -R
		Show commits in reverse chronological order.

	--total, -T
		Show the total number of commits for the given pathspec.

=head1 BUGS

	To file a bug report, please submit an issue at https://github.com/nickolasburr/git-follow/issues

=head1 AUTHOR

	Written by Nickolas Burr <nickolasburr@gmail.com>

=head1 SEE ALSO

	git-log(1), git-diff(1), git-config(1), git-revisions(1)

=cut
