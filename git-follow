#!/usr/bin/env perl

# Copyright (C) 2017 Nickolas Burr <nickolasburr@gmail.com>
# License under WTFPL (http://www.wtfpl.net/txt/copying/)

# git-follow: Follow lifetime changes (including renames)
# of a file through the complete history of a Git repository
use 5.008;
use Getopt::Long;
use strict;
use warnings;

# specific user error type messages
my $repo_not_found_error   = "Not a Git repository, exiting the script";
my $invalid_pathspec_error = "Not a valid pathspec, exiting the script";
my $invalid_usage_error    = "Usage: git follow [[--first|-f] | [--func|-F] | [--last|-l] | [--lines|-L] | [--reverse|-r]] filename";

# store length of `@ARGV`
my $argc = @ARGV;

# if `system` returns a non-zero exit status, meaning the
# current directory is not a Git repository, kill the script
!system("git rev-parse --is-inside-work-tree >/dev/null 2>&1") or die "$repo_not_found_error";

# if no arguments were given, emit an error and kill the script
$argc or die "$invalid_usage_error";

# store the last argument (which should be
# the filename the user is trying to track)
# and remove it from `@ARGV` array
my $filename = pop @ARGV;

# logical separator used to help differentiate
# between ambiguous flag options (and arguments),
# branch/revision/tag refs, and valid pathspecs
my $lsep = "--";

# verify `$filename` is a valid pathspec
if (! -e $filename) {
	die "$invalid_pathspec_error";
}

# flag options passed to the script
my %flags;

# optionally set `--no-pager` flag option,
# and `git` won't use a pager (e.g. less) to
# display logs, patch diffs, etc.
my $git_no_pager = undef;

# optionally set default view for diffs
# shown in `git log` (defaults to inline)
my $git_log_diff = "--color-words";

# default format to use for `git log --format` flag option
my $git_log_format = "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Commit:  %C(bold magenta)%h%Creset
* Tree:    %C(bold cyan)%t%Creset
* Message: %s
* Author:  %C(bold blue)%an%Creset %C(bold yellow)<%ae>%Creset
* When:    %C(bold green)%cr
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
";

# default `git log` flag options
my %git_log_flags = (
	"follow"    => "--follow",
	"format"    => "--format=$git_log_format",
	"graph"     => "--graph",
	"no-merges" => "--no-merges",
	"patch"     => "--patch-with-stat"
);

my @git_log_flag_values;

# flag options and their conflicting counterparts
my %cflags = (
	"reverse" => [
		"graph",
		"follow"
	]
);

# default argument values for flag options
my %dargs = (
	"last"  => 1,
	"lines" => 1
);

# base components of `git log` shell command, represented
# as an array to make it easier to pass to `system` builtin
my @git_log = (
	"git",
	"log"
);

# if `$git_no_pager` is defined,
# pass `--no-pager` flag to `git`
if (defined($git_no_pager)) {
	my $git = shift @git_log;
	unshift @git_log, ($git, $git_no_pager);
}

# determine if value is an integer
sub is_integer {
    my $num = shift;
	if (defined $num) {
		return $num =~ /^\d+$/ ? 1 : 0;
	} else {
		return 0;
	}
}

# get rev range for the given pathspec
sub get_revr {
	my $revr_start = shift;
	my $revr_end   = shift;
	# if there was no end rev range,
	# set default value to `HEAD`
	$revr_end = "HEAD" if not defined $revr_end;
	# if only an integer was given, interpolate
	# as a rev range for the current branch
	# --------------------------------------------
	# @todo: allow refname before '@{n}', either as flag option
	# argument (e.g. --branchname master --range 3 5) or passed
	# directly to `--range` (e.g. --range master 3 5)
	$revr_start = "\@{$revr_start}" if &is_integer($revr_start);
	$revr_end   = "\@{$revr_end}" if &is_integer($revr_end);
	return "$revr_start..$revr_end";
}

# format the `git log` flag with argument(s) given
sub get_format_rflag {
	my $flag = shift;
	my @args = shift;
	if ($flag eq "first") {
		return "--diff-filter=A";
	} elsif ($flag eq "func") {
		my $funcname = shift @args;
		return "-L^:$funcname:$filename";
	} elsif ($flag eq "last") {
		my $num = shift @args;
		if (!$num) {
			return "--max-count=1";
		} else {
			return "--max-count=$num";
		}
	} elsif ($flag eq "lines") {
		my @nums  = shift @args;
		my $lines = shift @nums;
		my $start = @$lines[0];
		my $end   = @$lines[1];
		if (!$end) {
			return "-L $start:$filename"
		} else {
			return "-L $start,$end:$filename";
		}
	} elsif ($flag eq "range") {
		my $revs       = shift @args;
		my $revr_start = @$revs[0];
		my $revr_end   = @$revs[1];
		return &get_revr($revr_start, $revr_end);
	} elsif ($flag eq "reverse") {
		return "--reverse";
	}
}

# map to `git log` flag options, format the
# command and pass it to `system` builtin
sub git_follow {
	my @command = ();
	# iterate through flag options and arguments (if applicable)
	while (my ($flag, $args) = each %flags) {
		my $rflag = &get_format_rflag($flag, $args);
		push @command, $rflag;
	}
	# update `@git_log_flag_values` with
	# corresponding `git log` flag options
	@git_log_flag_values = values %git_log_flags;
	# change the diff style, if applicable
	unshift @git_log_flag_values, $git_log_diff if defined $git_log_diff;
	unshift @command, @git_log, @git_log_flag_values;
	# add pathspec separator and filename
	push @command, $lsep, $filename;
	system @command;
}

# set argument value(s) for `$flag`,
# whether given to the flag or default
sub set_args {
	my $flag = shift;
	my $arg  = shift;
	if (!$arg) {
		$flags{$flag} = $dargs{$flag};
	} else {
		$flags{$flag} = $arg;
	}
}

# remove conflicting `git log` flag options so
# they're not passed to `system`, causing errors
sub rm_cflags {
	my $flag    = shift;
	my $cnflags = $cflags{$flag};
	foreach (values @$cnflags) {
		my $cnflag = shift @$cnflags;
		delete $git_log_flags{$cnflag};
	}
}

# add flag to `%git_log_flags` hash
sub set_aux_flag {
	my $nflag = shift;
	# get formatted `git log` flag
	my $rflag = &get_format_rflag($nflag);
	# remove conflicting flags
	&rm_cflags($nflag);
	# add aux flag to `%git_log_flags` hash
	$git_log_flags{$nflag} = $rflag;
}

# require flag options to be case-sensitive, positionally interchangeable,
# and able to accept a range of arguments, based on the flag
Getopt::Long::Configure(
	'no_ignore_case',
	'no_auto_abbrev',
	'no_getopt_compat',
	'require_order'
);

# get flag options and arguments passed to the script
GetOptions(
	\%flags,
	'first|f',
	'func|F=s{1,1}',
	'last|l=i{0,1}' => \&set_args,
	'lines|L=i@{1,2}',
	'range|r=s@{1,2}',
	'reverse|R'     => \&set_aux_flag
) or die "$invalid_usage_error";

# execute `git follow` command with flag options
&git_follow();
