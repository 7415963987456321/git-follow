#!/usr/bin/env perl

###
### git-follow - Follow lifetime changes of a pathspec in Git
###
### Copyright (C) 2017 Nickolas Burr <nickolasburr@gmail.com>
### Licensed under WTFNMFPL (https://goo.gl/ZDUPMZ)
###

use 5.008;
use strict;
use warnings;
use Getopt::Long;

# Current release version.
my $GIT_FOLLOW_VERSION = "1.1.3";

# If --version (or -V) was given as an option,
# print the current version number and exit.
if (grep { $_ eq "--version" || $_ eq "-V" } @ARGV) {
	&show_version();
}

# If --total (or -T) was given as an option, print
# total number of revisions for pathspec and exit.
if (grep { $_ eq "--total" || $_ eq "-T" } @ARGV) {
	&show_total();
}

###
### Environment variables
###

# Diff mode for patch views (defaults to inline).
my $GIT_FOLLOW_DIFF_MODE  = (defined $ENV{'GIT_FOLLOW_DIFF_MODE'})
                          ? $ENV{'GIT_FOLLOW_DIFF_MODE'}
                          : undef;

# Log format. Defaults to the following format:
# --------------------------------------------------------------
# commit (tree) - subject - author name <author email> [timestamp]
my $GIT_FOLLOW_LOG_FORMAT = (defined $ENV{'GIT_FOLLOW_LOG_FORMAT'})
                          ? $ENV{'GIT_FOLLOW_LOG_FORMAT'}
                          : "%C(bold cyan)%h%Creset (%C(bold magenta)%t%Creset) - %s - %C(bold blue)%an%Creset <%C(bold yellow)%ae%Creset> [%C(bold green)%cr%Creset]";

# No pager mode. Defaults to 0 (pager mode).
my $GIT_FOLLOW_NO_PAGER   = (defined $ENV{'GIT_FOLLOW_NO_PAGER'})
                          ? $ENV{'GIT_FOLLOW_NO_PAGER'}
                          : undef;
###
### User notices, errors
###

my $repo_not_found_error    = "Not a Git repository.";
my $invalid_pathspec_error  = "Not a valid pathspec.";
my $invalid_branchref_error = "Not a valid branch.";
my $invalid_tagref_error    = "Not a valid tag.";
my $invalid_refspec_combo   = "Only one --branch or one --tag option can be specified at a time.";
my $invalid_usage_error     = <<"END_INVALID_USAGE_ERROR";

  Usage: git follow [OPTIONS] [--] pathspec

  Options:

    --branch,     -b <branchref>             Show commits for pathspec, specific to a branch.
    --first,      -f                         Show first commit where Git initiated tracking of pathspec.
    --func,       -F <funcname>              Show commits which affected function <funcname> in pathspec.
    --last,       -l [<count>]               Show last <count> commits which affected pathspec. Omitting <count> defaults to last commit.
    --lines,      -L <start> [<end>]         Show commits which affected lines <start> through <end> in pathspec. Omitting <end> defaults to EOF.
    --no-merges,  -M                         Show commits that have a maximum of one parent. See --no-merges of git-log(1).
    --no-patch,   -N                         Suppress diff output. See --no-patch of git-log(1).
    --no-renames, -O                         Disable rename detection. See --no-renames of git-log(1).
    --range,      -r <startref> [<endref>]   Show commits in range <startref> to <endref> which affected pathspec. Omitting <endref> defaults to HEAD. See gitrevisions(1).
    --reverse,    -R                         Show commits in reverse chronological order. See --walk-reflogs of git-log(1).
    --tag,        -t <tagref>                Show commits for pathspec, specific to a tag.
    --total,      -T                         Show total number of commits for pathspec.
    --version,    -V                         Show current version number.

END_INVALID_USAGE_ERROR

###
### git-follow(1) subroutines
###

sub is_int;
sub get_revr;
sub get_format_ropt;
sub rm_copts;
sub set_args;
sub set_aux_opt;
sub set_refspec;
sub show_total;

# If `system` returns non-zero exit status, kill the script.
!system("git rev-parse --is-inside-work-tree >/dev/null 2>&1") or die "$repo_not_found_error";

# If no arguments were given (e.g. `git follow`, no pathspec),
# emit an error message with usage details and kill the script.
@ARGV or die "$invalid_usage_error";

# Options passed to `git-follow`.
my %options;

# Name of pathspec given as an argument to git-follow.
my $pathspec = $ARGV[$#ARGV];

# Logical separator used to help differentiate
# between ambiguous options, option arguments,
# branch/revision/tag refs, and valid pathspecs.
my $lsep = "--";

# Target refspec (when either `--branch` or `--tag` option is specified).
my $refspec = undef;

# Default `git log` options.
my %git_log_options = (
	"follow"     => "--follow",
	"format"     => "--format=$GIT_FOLLOW_LOG_FORMAT",
	"graph"      => "--graph",
	"patch"      => "--patch-with-stat",
);

my @git_log_option_values;

# Options and their conflicting counterparts.
my %copts = (
	"no-patch"   => [
		"patch",
	],
	"no-renames" => [
		"follow",
	],
	"reverse"    => [
		"graph",
		"follow",
	],
);

# Default argument values for options that accept arguments.
my %dargs = (
	"last"  => 1,
	"lines" => 1,
);

# Base components of `git log` shell command, represented
# as an array to make it easier to pass to `system` builtin.
my @git_log = (
	"git",
	"log",
);

# Determine if value is an integer.
sub is_int {
	my $num = shift;

	if (defined $num) {
		return $num =~ /^\d+$/ ? 1 : 0;
	} else {
		return 0;
	}
}

# Get rev range for the given pathspec.
sub get_revr {
	my $revr_start = shift;
	my $revr_end   = shift;

	# If no end rev was given, default to HEAD.
	$revr_end = "HEAD" if not defined $revr_end;

	# If only an integer was given, interpolate
	# as a rev range for the current branch.
	# --------------------------------------------
	# @todo: Allow refname before '@{n}', either as argument
	# (e.g. --branch master --range 3 5), or passed directly
	# to --range option (e.g. --range master 3 5).
	$revr_start = "\@{$revr_start}" if &is_int($revr_start);
	$revr_end   = "\@{$revr_end}" if &is_int($revr_end);

	return "$revr_start..$revr_end";
}

# Format the `git log` flag with argument(s) given.
sub get_format_ropt {
	my ($opt, @args) = @_;

	if ($opt eq "first") {
		return "--diff-filter=A";
	} elsif ($opt eq "func") {
		my $funcname = shift @args;

		return "-L^:$funcname:$pathspec";
	} elsif ($opt eq "last") {
		my $num = shift @args;

		if (!$num) {
			$num = 1;
		}

		return "--max-count=$num";
	} elsif ($opt eq "lines") {
		my @nums  = shift @args;
		my $lines = shift @nums;
		my $start = @$lines[0];
		my $end   = @$lines[1];

		# If no end range was given, only specify start and pathspec.
		if (!$end) {
			return "-L $start:$pathspec"
		} else {
			return "-L $start,$end:$pathspec";
		}
	} elsif ($opt eq "range") {
		my $revs       = shift @args;
		my $revr_start = @$revs[0];
		my $revr_end   = @$revs[1];

		return &get_revr($revr_start, $revr_end);
	} else {
		return "--$opt";
	}
}

# Remove conflicting `git log` options so they're
# not passed to `system`, causing conflict errors.
sub rm_copts {
	my $opt = shift;
	my $cnopts = $copts{$opt};

	foreach (values @$cnopts) {
		my $cnopt = shift @$cnopts;
		delete $git_log_options{$cnopt} if exists $git_log_options{$cnopt};
	}
}

# Set argument for `$opt` whether,
# given to the option or default.
sub set_args {
	my ($opt, $arg) = @_;

	# Update %options hash with either the given option
	# argument or with the default option argument.
	$options{$opt} = !$arg ? $dargs{$opt} : $arg;
}

# Add option to `%git_log_options`.
sub set_aux_opt {
	my $nopt = shift;
	# Get formatted `git log` option.
	my $ropt = &get_format_ropt($nopt);

	# Remove conflicting options, add aux option to `%git_log_options`.
	&rm_copts($nopt);
	$git_log_options{$nopt} = $ropt;
}

# Update package-level `$refspec` with ref given via --branch or --tag.
sub set_refspec {
	# If `$refspec` is already defined, notify the user and emit an error,
	# as you can't give both `--branch` and `--tag` options simultaneously.
	if (defined $refspec) {
		die "$invalid_refspec_combo";
	}

	# Option name (branch, tag), and refspec (e.g. 'master', 'v1.0.5').
	my ($opt, $ref) = @_;

	my $refs = `git $opt --list`;
	my $remotes = `git branch -r` if $opt eq "branch";
	$refs = $refs . $remotes if defined $remotes;

	# Filter asterisk, escape codes from `git {branch,tag} --list`.
	$refs =~ s/\*//gi;
	$refs =~ s/\033\[\d*(;\d*)*m//g;

	# Split refspecs into an array, trim whitespace from each element.
	my @refspecs = split "\n", $refs;
	@refspecs = grep { $_ =~ s/^\s+//; $_; } @refspecs;

	# If `$ref` is indeed a valid refspec, update `$refspec`.
	if (grep /^$ref$/, @refspecs) {
		$refspec = $ref;
	} else {
		# Otherwise, emit an error specific to
		# the option given and exit the script
		# ------------------------------------
		# @todo Create a hash for mapping refs
		# to their subsequent error messages
		if ($opt eq "branch") {
			die "$invalid_branchref_error";
		} elsif ($opt eq "tag") {
			die "$invalid_tagref_error";
		}
	}
}

# Show total number of commits for pathspec.
sub show_total {
	my $fopt = (grep { $_ eq "--no-renames" || $_ eq "-O" } @ARGV)
	         ? "--no-renames"
	         : "--follow";

	my $path = (defined $pathspec)
	         ? $pathspec
	         : $ARGV[$#ARGV];

	# Array of abbreviated commit hashes.
	my @hashes = `git log $fopt --format=\"%h\" -- $path`;

	print scalar @hashes;
	print "\n";

	exit 0;
}

# Show current release version.
sub show_version {
	print "$GIT_FOLLOW_VERSION\n";

	exit 0;
}

Getopt::Long::Configure(
	'no_auto_abbrev',
	'no_ignore_case',
	'require_order',
);

Getopt::Long::GetOptions(
	\%options,
	'branch|b=s{1,1}'  => \&set_refspec,
	'first|f',
	'func|F=s{1,1}',
	'last|l=i{0,1}'    => \&set_args,
	'lines|L=i@{1,2}',
	'no-merges|M'      => \&set_aux_opt,
	'no-patch|N'       => \&set_aux_opt,
	'no-renames|O'     => \&set_aux_opt,
	'range|r=s@{1,2}',
	'reverse|R'        => \&set_aux_opt,
	'tag|t=s{1,1}'     => \&set_refspec,
	'total|T',
	'version|V',
) or die "$invalid_usage_error";

# Map to `git log` options, format the
# command and pass to `system` builtin.
my @command = ();

# Iterate through options and option arguments (if applicable).
while (my ($opt, $args) = each %options) {
	my $ropt = &get_format_ropt($opt, $args);
	push @command, $ropt;
}

# If `$GIT_FOLLOW_NO_PAGER` is defined,
# pass `--no-pager` option to `git`.
if (defined $GIT_FOLLOW_NO_PAGER) {
	my $git = shift @git_log;
	unshift @git_log, ($git, "--no-pager");
}

# Update `@git_log_option_values` with
# corresponding `git log` options.
@git_log_option_values = values %git_log_options;

# Change the diff style, if applicable.
unshift @git_log_option_values, $GIT_FOLLOW_DIFF_MODE if defined $GIT_FOLLOW_DIFF_MODE;
unshift @command, @git_log, @git_log_option_values;

# Add refspec, if given as an argument to --branch or --tag.
push @command, $refspec if defined $refspec;
push @command, $lsep, $pathspec;

system @command;

1;

__END__

=pod

=encoding UTF-8

=head1 NAME

	git-follow - Follow lifetime changes of a pathspec in Git

=head1 VERSION

	version 1.1.3

=head1 DESCRIPTION

	Follow lifetime changes of a pathspec in Git. git-follow(1) makes analyzing changes of a pathspec trivial with robust options and simplified log output.

=head1 ENVIRONMENT

	GIT_FOLLOW_DIFF_MODE
		Diff mode. Defaults to inline. See --word-diff, --color-words, et al. of git-log(1) for syntax.

	GIT_FOLLOW_LOG_FORMAT
		Log format. See --format of git-log(1) for syntax.

	GIT_FOLLOW_NO_PAGER
		Disable pager. Defaults to 0. Set to 1 to disable pager. Has equivalent effect of 'git --no-pager follow ...'. See --no-pager of git(1).

=head1 OPTIONS

	--branch, -b <branchref>
		Show commits for pathspec, specific to a branch.

	--first, -f
		Show first commit where Git initiated tracking of pathspec.

	--func, -F <funcname>
		Show commits which affected function <funcname> in pathspec. See -L of git-log(1).

	--last, -l [<count>]
		Show last <count> commits which affected pathspec. Omitting <count> defaults to last commit.

	--lines, -L <start> [<end>]
		Show commits which affected lines <start> through <end> in pathspec. Omitting <end> defaults to EOF.

	--no-merges, -M
		Show commits that have a maximum of one parent. See --no-merges of git-log(1).

	--no-patch, -N
		Suppress diff output. See --no-patch of git-log(1).

	--no-renames, -O
		Disable rename detection. See --no-renames of git-log(1).

	--range, -r <startref> [<endref>]
		Show commits in range <startref> to <endref> which affected pathspec. Omitting <endref> defaults to HEAD. See git-revisions(1).

	--reverse, -R
		Show commits in reverse chronological order. See --walk-reflogs of git-log(1).

	--tag, -t <tagref>
		Show commits for pathspec, specific to a tag.

	--total, -T
		Show total number of commits for pathspec.

	--version, -V
		Show current version number.

=head1 NOTES

	Like standard Git builtins, git-follow supports an optional pathspec delimiter [--] to help disambiguate options, option arguments, and refs from pathspecs.

=head1 EXAMPLES

	Display commits on branch 'topic'
		git follow --branch topic -- blame.c

	Display first commit where Git initiated tracking
		git follow --first -- branch.c

	Display last 5 commits
		git follow --last 5 -- Makefile

	Display last commit where lines 5 through `EOF' were affected
		git follow --last --lines 5 -- apply.c

	Display last 3 commits where lines 10 through 15 were affected
		git follow --last 3 --lines 10 15 -- bisect.c

	Display commits where function `funcname' was affected
		git follow --func funcname -- archive.c

	Display commits in range fifth ancestor of master to HEAD
		git follow --range master@{5} -- worktree.c

		--OR--

		Same as above (assuming currently checked out branch is master).

		git follow --range 5 -- worktree.c

	Display commits between two days ago and one hour ago
		git follow --range 'master@{2 days ago}' 'master@{1 hour ago}' -- apply.c

	Display commits up to tag v1.5.3
		git follow --tag v1.5.3 -- graph.c

	Display total number of commits
		git follow --total -- rebase.c

=head1 BUGS

	https://github.com/nickolasburr/git-follow/issues

=head1 AUTHOR

	Written by Nickolas Burr <nickolasburr@gmail.com>

=head1 SEE ALSO

	git(1), git-branch(1), git-check-ref-format(1), git-config(1), git-diff(1), git-log(1), git-remote(1), git-revisions(1), git-tag(1)

=cut

# vim: syntax=perl
