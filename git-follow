#!/usr/bin/env perl

###
### git-follow - Follow lifetime changes of a pathspec in Git
###
### Copyright (C) 2017 Nickolas Burr <nickolasburr@gmail.com>
### Licensed under WTFNMFPL (https://goo.gl/ZDUPMZ)
###

use 5.008;
use strict;
use warnings;
use Getopt::Long;

###
### To make git-follow(1) a standalone package and avoid requiring external dependencies for use,
### String::ShellQuote package (https://goo.gl/Fmv1PF) is inlined for convenience and portability
###

###
### Begin String::ShellQuote package
###

sub croak {
	require Carp;
	goto &Carp::croak;
}

sub _shell_quote_backend {
	my @in = @_;
	my @err = ();

	if (0) {
		require RS::Handy;
		print RS::Handy::data_dump(\@in);
	}

	return \@err, '' unless @in;

	my $ret = '';
	my $saw_non_equal = 0;

	foreach (@in) {
		if (!defined $_ or $_ eq '') {
			$_ = "''";
			next;
		}

		if (s/\x00//g) {
			push @err, "No way to quote string containing null (\\000) bytes";
		}

		my $escape = 0;

		# = needs quoting when it's the first element (or part of a
		# series of such elements), as in command position it's a
		# program-local environment setting

		if (/=/) {
			if (!$saw_non_equal) {
				$escape = 1;
			}
		} else {
			$saw_non_equal = 1;
		}

		if (m|[^\w!%+,\-./:=@^]|) {
				$escape = 1;
		}

		if ($escape || (!$saw_non_equal && /=/)) {
			# ' -> '\''
			s/'/'\\''/g;

			# make multiple ' in a row look simpler
			# '\'''\'''\'' -> '"'''"'
			s|((?:'\\''){2,})|q{'"} . (q{'} x (length($1) / 4)) . q{"'}|ge;

			$_ = "'$_'";
			s/^''//;
			s/''$//;
		}
	}

	continue {
		$ret .= "$_ ";
	}

	chop $ret;
	return \@err, $ret;
}

sub shell_comment_quote {
	return '' unless @_;

	unless (@_ == 1) {
		croak "Too many arguments to shell_comment_quote " . "(got " . @_ . " expected 1)";
	}

	local $_ = shift;
	s/\n/\n#/g;
	return $_;
}

sub shell_quote_best_effort {
	my ($rerr, $s) = _shell_quote_backend @_;
	return $s;
}

sub shell_quote {
	my ($rerr, $s) = _shell_quote_backend @_;

	if (@$rerr) {
		my %seen;
		@$rerr = grep { !$seen{$_}++ } @$rerr;
		my $s  = join '', map { "shell_quote(): $_\n" } @$rerr;
		chomp $s;
		croak $s;
	}
	return $s;
}

###
### End String::ShellQuote package
###

###
### Begin git-follow(1)
###

my $GIT_FOLLOW_VERSION = "1.1.3";

# If --version (or -V) was given as an option,
# print the current version number and exit.
if (grep { $_ eq "--version" || $_ eq "-V" } @ARGV) {
	print "$GIT_FOLLOW_VERSION\n";

	exit 0;
}

###
### Environment variables
###

# Diff mode for patch views (defaults to inline).
my $GIT_FOLLOW_DIFF_MODE  = (defined $ENV{'GIT_FOLLOW_DIFF_MODE'})
                          ? $ENV{'GIT_FOLLOW_DIFF_MODE'}
                          : undef;

# Log format. Defaults to the following format:
# --------------------------------------------------------------
# commit (tree) - subject - author name <author email> [timestamp]
my $GIT_FOLLOW_LOG_FORMAT = (defined $ENV{'GIT_FOLLOW_LOG_FORMAT'})
                          ? $ENV{'GIT_FOLLOW_LOG_FORMAT'}
                          : "%C(bold cyan)%h%Creset (%C(bold magenta)%t%Creset) - %s - %C(bold blue)%an%Creset <%C(bold yellow)%ae%Creset> [%C(bold green)%cr%Creset]";

# No pager mode. Defaults to 0 (pager mode).
my $GIT_FOLLOW_NO_PAGER   = (defined $ENV{'GIT_FOLLOW_NO_PAGER'})
                          ? $ENV{'GIT_FOLLOW_NO_PAGER'}
                          : undef;
###
### User notices, errors
###

my $repo_not_found_error    = "Not a Git repository.";
my $invalid_pathspec_error  = "Not a valid pathspec.";
my $invalid_branchref_error = "Not a valid branch.";
my $invalid_tagref_error    = "Not a valid tag.";
my $invalid_refspec_combo   = "Only one --branch or one --tag option can be specified at a time.";
my $invalid_usage_error     = <<"END_INVALID_USAGE_ERROR";

	Usage: git follow [OPTIONS] [--] pathspec

	Options:

	--branch,     -b <branchref>             Show commits specific to a branch.
	--first,      -f                         Show first commit where Git initiated tracking of pathspec.
	--func,       -F <funcname>              Show commits which affected function <funcname> in pathspec.
	--last,       -l [<count>]               Show last <count> commits which affected pathspec. Omitting <count> defaults to last commit.
	--lines,      -L <start> [<end>]         Show commits which affected lines <start> through <end> in pathspec. Omitting <end> defaults to EOF.
	--no-merges,  -M                         Show commits that have a maximum of one parent. See --no-merges of git-log(1).
	--no-patch,   -N                         Suppress diff output. See --no-patch of git-log(1).
	--no-renames, -O                         Disable rename detection. See --no-renames of git-log(1).
	--range,      -r <startref> [<endref>]   Show commits in range <startref> to <endref> which affected pathspec. Omitting <endref> defaults to HEAD. See gitrevisions(1).
	--reverse,    -R                         Show commits in reverse chronological order. See --walk-reflogs of git-log(1).
	--tag,        -t <tagref>                Show commits specific to a tag.
	--total,      -T                         Show total number of commits for pathspec.
	--version,    -V                         Show current version number.

END_INVALID_USAGE_ERROR

###
### git-follow(1) subroutines
###

sub is_int;
sub get_revr;
sub get_format_ropt;
sub rm_cflags;
sub set_args;
sub set_aux_opt;
sub set_branchname;
sub set_ns_pipe;

# If `system` returns non-zero exit status, kill the script.
!system("git rev-parse --is-inside-work-tree >/dev/null 2>&1") or die "$repo_not_found_error";

my $argc = @ARGV;

# If no arguments were given (e.g. `git follow`, no pathspec),
# emit an error message with usage details and kill the script.
$argc or die "$invalid_usage_error";

# Name of pathspec given as an argument to git-follow.
my $pathspec = pop @ARGV;

if (! -e $pathspec) {
	die "$invalid_pathspec_error";
}

my %options;

# Logical separator used to help differentiate
# between ambiguous flag options (and arguments),
# branch/revision/tag refs, and valid pathspecs.
my $lsep = "--";

# Target refspec (when either `--branch` or `--tag` option is specified).
my $refspec = undef;

# Default `git log` options.
my %git_log_options = (
	"follow"     => "--follow",
	"format"     => "--format=$GIT_FOLLOW_LOG_FORMAT",
	"graph"      => "--graph",
	"no-renames" => "--no-renames",
	"patch"      => "--patch-with-stat",
);

my @git_log_option_values;

# Options and their conflicting counterparts.
my %copts = (
	"no-patch"   => [
		"patch",
	],
	"no-renames" => [
		"follow",
	],
	"reverse"    => [
		"graph",
		"follow",
	],
);

# Default argument values for flag options
my %dargs = (
	"last"  => 1,
	"lines" => 1,
);

# Base components of `git log` shell command, represented
# as an array to make it easier to pass to `system` builtin.
my @git_log = (
	"git",
	"log",
);

# Non-standard pipelines for use with alternate
# syntax of `git log` and non `git log` commands.
my %ns_pipes = (
	"total" => [
		"git",
		"log",
		"--follow",
		"--format='%h'",
		"$lsep",
		"$pathspec",
	],
);

# Determine if value is an integer.
sub is_int {
	my $num = shift;

	if (defined $num) {
		return $num =~ /^\d+$/ ? 1 : 0;
	} else {
		return 0;
	}
}

# Get rev range for the given pathspec.
sub get_revr {
	my $revr_start = shift;
	my $revr_end   = shift;

	# If there was no end rev range,
	# set default value to `HEAD`
	$revr_end = "HEAD" if not defined $revr_end;

	# If only an integer was given, interpolate
	# as a rev range for the current branch.
	# --------------------------------------------
	# @todo: Allow refname before '@{n}', either as flag option
	# argument (e.g. --branchname master --range 3 5) or passed
	# directly to `--range` (e.g. --range master 3 5).
	$revr_start = "\@{$revr_start}" if &is_int($revr_start);
	$revr_end   = "\@{$revr_end}" if &is_int($revr_end);

	return "$revr_start..$revr_end";
}

# Format the `git log` flag with argument(s) given
sub get_format_ropt {
	my ($opt, @args) = @_;

	if ($opt eq "first") {
		return "--diff-filter=A";
	} elsif ($opt eq "func") {
		my $funcname = shift @args;

		return "-L^:$funcname:$pathspec";
	} elsif ($opt eq "last") {
		my $num = shift @args;

		if (!$num) {
			$num = 1;
		}

		return "--max-count=$num";
	} elsif ($opt eq "lines") {
		my @nums  = shift @args;
		my $lines = shift @nums;
		my $start = @$lines[0];
		my $end   = @$lines[1];

		# If no end range was given, only specify start and pathspec.
		if (!$end) {
			return "-L $start:$pathspec"
		} else {
			return "-L $start,$end:$pathspec";
		}
	} elsif ($opt eq "range") {
		my $revs       = shift @args;
		my $revr_start = @$revs[0];
		my $revr_end   = @$revs[1];

		return &get_revr($revr_start, $revr_end);
	} else {
		return "--$opt";
	}
}

# Remove conflicting `git log` options so they're
# not passed to `system`, causing conflict errors.
sub rm_copts {
	my $opt = shift;
	my $cnopts = $copts{$opt};

	foreach (values @$cnopts) {
		my $cnopt = shift @$cnopts;
		delete $git_log_options{$cnopt} if exists $git_log_options{$cnopt};
	}
}

# Set argument for `$opt` whether,
# given to the option or default.
sub set_args {
	my ($opt, $arg) = @_;

	# Update %options hash with either the given option
	# argument or with the default option argument.
	$options{$opt} = !$arg ? $dargs{$opt} : $arg;
}

# Add option to `%git_log_options`.
sub set_aux_opt {
	my $nopt = shift;
	# Get formatted `git log` option.
	my $ropt = &get_format_ropt($nopt);

	# Remove conflicting options, add aux option to `%git_log_options`.
	&rm_copts($nopt);
	$git_log_options{$nopt} = $ropt;
}

# Update package-level `$refspec` with ref given via --branch or --tag.
sub set_refspec {
	# If `$refspec` is already defined, notify the user and emit an error,
	# as you can't give both `--branch` and `--tag` options simultaneously.
	if (defined $refspec) {
		die "$invalid_refspec_combo";
	}

	# Option name (branch, tag), and refspec (e.g. 'master', 'v1.0.5').
	my ($opt, $ref) = @_;

	my $refs = `git $opt --list`;
	my $remotes = `git branch -r` if $opt eq "branch";
	$refs = $refs . $remotes if defined $remotes;

	# Filter asterisk, escape codes from `git {branch,tag} --list`.
	$refs =~ s/\*//gi;
	$refs =~ s/\033\[\d*(;\d*)*m//g;

	# Split refspecs into an array, trim whitespace from each element.
	my @refspecs = split "\n", $refs;
	@refspecs = grep { $_ =~ s/^\s+//; $_; } @refspecs;

	# If `$ref` is indeed a valid refspec, update `$refspec`.
	if (grep /^$ref$/, @refspecs) {
		$refspec = $ref;
	} else {
		# Otherwise, emit an error specific to
		# the option given and exit the script
		# ------------------------------------
		# @todo Create a hash for mapping refs
		# to their subsequent error messages
		if ($opt eq "branch") {
			die "$invalid_branchref_error";
		} elsif ($flag eq "tag") {
			die "$invalid_tagref_error";
		}
	}
}

# Set non-standard pipeline that either circumvents `git log`, or uses
# an alternate syntax, which is essential for options like `--total`.
sub set_ns_pipe {
	my $flag = shift;
	my $pipe = $ns_pipes{$flag};

	if ($flag eq "total") {
		my $command = &shell_quote(@$pipe);

		# Array of abbreviated commit hashes.
		my @hashes = `$command`;
		my $total  = @hashes;

		print "$total\n";

		exit 0;
	}
}

Getopt::Long::Configure(
	'no_auto_abbrev',
	'no_ignore_case',
	'require_order',
);

Getopt::Long::GetOptions(
	\%options,
	'branch|b=s{1,1}'  => \&set_refspec,
	'first|f',
	'func|F=s{1,1}',
	'last|l=i{0,1}'    => \&set_args,
	'lines|L=i@{1,2}',
	'no-merges|M'      => \&set_aux_opt,
	'no-patch|N'       => \&set_aux_opt,
	'no-renames|O'     => \&set_aux_opt,
	'range|r=s@{1,2}',
	'reverse|R'        => \&set_aux_opt,
	'tag|t=s{1,1}'     => \&set_refspec,
	'total|T'          => \&set_ns_pipe,
	'version|V',
) or die "$invalid_usage_error";

# Map to `git log` options, format the
# command and pass to `system` builtin.
my @command = ();

# Iterate through options and option arguments (if applicable).
while (my ($flag, $args) = each %options) {
	my $rflag = &get_format_ropt($flag, $args);
	push @command, $rflag;
}

# If `$GIT_FOLLOW_NO_PAGER` is defined,
# pass `--no-pager` option to `git`.
if (defined $GIT_FOLLOW_NO_PAGER) {
	my $git = shift @git_log;
	unshift @git_log, ($git, "--no-pager");
}

# Update `@git_log_option_values` with
# corresponding `git log` options.
@git_log_option_values = values %git_log_options;

# Change the diff style, if applicable.
unshift @git_log_option_values, $GIT_FOLLOW_DIFF_MODE if defined $GIT_FOLLOW_DIFF_MODE;
unshift @command, @git_log, @git_log_option_values;

# Add refspec, if given as an argument to --branch or --tag.
push @command, $refspec if defined $refspec;
push @command, $lsep, $pathspec;

system @command;

1;

###
### End git-follow(1)
###

__END__

=pod

=encoding UTF-8

=head1 NAME

	git-follow - Follow lifetime changes of a pathspec in Git

=head1 VERSION

	version 1.1.3

=head1 DESCRIPTION

	Follow lifetime changes of a pathspec in Git. git-follow(1) makes analyzing changes of a pathspec trivial with robust options and simplified log output.

=head1 ENVIRONMENT

	GIT_FOLLOW_DIFF_MODE
		Diff mode. Defaults to inline. See --word-diff, --color-words, et al. of git-log(1) for syntax.

	GIT_FOLLOW_LOG_FORMAT
		Log format. See --format of git-log(1) for syntax.

	GIT_FOLLOW_NO_PAGER
		Disable pager. Defaults to 0. Set to 1 to disable the pager. Has equivalent effect of 'git --no-pager follow ...'. See --no-pager of git(1).

=head1 OPTIONS

	--branch, -b <branchref>
		Show commits specific to a branch.

	--first, -f
		Show first commit where Git initiated tracking of pathspec.

	--func, -F <funcname>
		Show commits which affected function <funcname> in pathspec. See -L of git-log(1).

	--last, -l [<count>]
		Show last <count> commits which affected pathspec. Omitting <count> defaults to last commit.

	--lines, -L <start> [<end>]
		Show commits which affected lines <start> through <end> in pathspec. Omitting <end> defaults to EOF.

	--no-merges, -M
		Show commits that have a maximum of one parent. See --no-merges of git-log(1).

	--no-patch, -N
		Suppress diff output. See --no-patch of git-log(1).

	--no-renames, -O
		Disable rename detection. See --no-renames of git-log(1).

	--range, -r <startref> [<endref>]
		Show commits in range <startref> to <endref> which affected pathspec. Omitting <endref> defaults to HEAD. See git-revisions(1).

	--reverse, -R
		Show commits in reverse chronological order. See --walk-reflogs of git-log(1).

	--tag, -t <tagref>
		Show commits specific to a tag.

	--total, -T
		Show total number of commits for pathspec.

	--version, -V
		Show current version number.

=head1 NOTES

	Like standard Git builtins, git-follow supports an optional pathspec delimiter [--] to help disambiguate options, option arguments, and refs from pathspecs.

=head1 EXAMPLES

	Display commits on branch 'topic'
		git follow --branch topic -- blame.c

	Display first commit where Git initiated tracking
		git follow --first -- branch.c

	Display last 5 commits
		git follow --last 5 -- Makefile

	Display last commit where lines 5 through `EOF' were affected
		git follow --last --lines 5 -- apply.c

	Display last 3 commits where lines 10 through 15 were affected
		git follow --last 3 --lines 10 15 -- bisect.c

	Display commits where function `funcname' was affected
		git follow --func funcname -- archive.c

	Display commits in range fifth ancestor of master to HEAD
		git follow --range master@{5} -- worktree.c

		--OR--

		Same as above (assuming currently checked out branch is master).

		git follow --range 5 -- worktree.c

	Display commits between two days ago and one hour ago
		git follow --range 'master@{2 days ago}' 'master@{1 hour ago}' -- apply.c

	Display commits up to tag v1.5.3
		git follow --tag v1.5.3 -- graph.c

	Display total number of commits
		git follow --total -- rebase.c

=head1 BUGS

	https://github.com/nickolasburr/git-follow/issues

=head1 AUTHOR

	Written by Nickolas Burr <nickolasburr@gmail.com>

=head1 SEE ALSO

	git(1), git-branch(1), git-check-ref-format(1), git-config(1), git-diff(1), git-log(1), git-remote(1), git-revisions(1), git-tag(1)

=cut

# vim: syntax=perl
