#!/usr/bin/env perl

# Copyright (C) 2017 Nickolas Burr <nickolasburr@gmail.com>
# License under WTFPL (http://www.wtfpl.net/txt/copying/)

# git-track: Track lifetime changes (including renames) of a file
# throughout the complete history of a Git repository
use 5.008;
use strict;
use warnings;
use File::Basename qw(basename);

# verify we're in a Git repository before anything else
if (system("git rev-parse --is-inside-work-tree >/dev/null 2>&1") != 0) {
	die "Could not locate the Git repository. Please verify you're inside a directory under Git version control";
}

# store copy of `@ARGV` that we can freely manipulate
my @argv = @ARGV;

# store the last argument (which should be
# the filename the user is trying to track)
# and remove it from `@argv` array
my $filename = pop @argv;

# store length of `@argv` (after pop)
my $argc = @argv;

# base components of `git log` shell command, represented
# as an array to make it easier to pass to `system` builtin
my @git_log = (
	"git",
	"log"
);

# default format to use for `git log --format` flag option
my $git_log_default_format = "%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset%n";

# optionally set default view for diffs
# shown in `git log` (defaults to inline)
my $git_log_default_diff = "--side-by-side";

# applicable `git log` flag options
my @git_log_flags = (
	"--follow",
	"--format='$git_log_default_format'",
	"--graph",
	"--no-merges",
	"--patch-with-stat"
);

# default error message to pass to `die` builtin
# when an invalid flag is passed to the script
my $git_track_default_error_message = "Invalid flag given\nUsage: git track {-f[--first]|-F[--func]|-l[--last]|-L[--lines]|-r[--reverse]} filename";

# custom error message to pass to `die` builtin
# when two or more mutually-exclusive flags
# are given as arguments to the script
my $git_track_mutins_error_message = "Illegal flag combination\nUsage: git track {-f[--first]|-F[--func]|-l[--last]|-L[--lines]|-r[--reverse]} filename";

# map `git track` flags to actual `git log`
# flags that can be passed along to the shell
my %git_track_map_flags = (
	"--first"        => "--diff-filter",
	"--func"         => "-L",
	"--last"         => "--max-count",
	"--lines"        => "-L",
	"--reverse"      => "--reverse",
	"--side-by-side" => "--color-words"
);

# `git track` flag options that have a mapping
# to an actual `git log` flag option
my @git_track_flags = keys %git_track_map_flags;

# `git track` flag option aliases that can be
# used as shorthand flag options instead
my %git_track_map_aliases = (
	"-f" => "--first",
	"-F" => "--func",
	"-l" => "--last",
	"-L" => "--lines",
	"-s" => "--side-by-side",
	"-r" => "--reverse"
);

# `git track` flag options that have a valid
# shorthand flag option that can be substituted
my @git_track_aliases = keys %git_track_map_aliases;

# `git track` mutually-inclusive flag options
my %git_track_flag_mutins = (
	"--first"        => [
		"--func",
		"--lines",
		"--side-by-side"
	],
	"--func"         => [
		"--first",
		"--last",
		"--side-by-side",
		"--reverse"
	],
	"--last"         => [
		"--func",
		"--lines",
		"--side-by-side"
	],
	"--lines"        => [
		"--first",
		"--last",
		"--reverse",
		"--side-by-side"
	],
	"--reverse"      => [
		"--func",
		"--lines",
		"--side-by-side"
	],
	"--side-by-side" => [
		"--first",
		"--func",
		"--last",
		"--lines",
		"--reverse"
	]
);

my @git_track_mutins = keys %git_track_flag_mutins;

# determine if a flag has conflicts with other flags
# that were passed earlier in the cycle
sub has_conflicts {
	my @flags  = @_;
	my $nindex = 1;
	# iterate over flags given as arguments to the
	# script that we need to check for conflicts
	foreach my $flag (@flags) {
		# the next flag in the array of arguments
		my $nflag = $flags[$nindex];
		# if `$nflag` is undefined (we've reached the end
		# of the array of arguments), return status code 0,
		# as we can safely assume there weren't conflicts
		if (!defined $nflag) {
			return 0;
		}
		# array of mutually-inclusive flag options
		# that can be used in conjunction with `$flag`
		my @mutins = @{$git_track_flag_mutins{$flag}};
		# determine if the next flag is legal, given what
		# we already know from previous flag options
		my $in_array = grep { $nflag eq $_ } @mutins;
		# if `$in_array` returns 0 (missing from array)
		# return an status code 1 (conflicts found)
		if (!$in_array) {
			return 1;
		}
		$nindex++;
	}
	# otherwise, return 0 (no conflicts found)
	return 0;
}

# get the correctly mapped flag option, deriving from
# a `git track` flag option and mapping to a `git log`
# flag option, while ignoring any shorthands flags
# > see `&get_flag_longhand` for further clarity
sub get_flag {
	my $flag = shift;
	if (grep { $flag eq $_ } @git_track_flags) {
		$git_track_map_flags{$flag};
	} else {
		undef;
	}
}

# get implicit `git track` longhand flag option
# from either a longhand flag (return itself) or
# a shorthand value, mapped to its corresponding
# longhand flag option in `%git_track_map_aliases`
sub get_flag_longhand {
	my $flag = shift;
	# if the flag given was a valid longhand value,
	# simply return its value back to the caller
	if (grep { $flag eq $_ } @git_track_flags) {
		$flag;
	# if the flag given was a valid shorthand (alias) value,
	# map the flag to its longhand counterpart and return the
	# longhand flag to the caller in place of the shorthand
	} elsif (grep { $flag eq $_ } @git_track_aliases) {
		$git_track_map_aliases{$flag};
	# otherwise, return `undef` since `$value` didn't match anything
	} else {
		undef;
	}
}

# get flag mappings and put them into an array
sub get_flags {
	my @flags   = @_;
	my @options = ();
	foreach my $option (@flags) {
		# longhand of the flag option (if it's a shorthand flag)
		$option = &get_flag_longhand($option);
		if (!&get_flag($option)) {
			die "$git_track_default_error_message";
		}
		push @options, $option;
	}
	@options;
}

# get special formatting for specific flag options
# @todo: Finish building this subroutine
sub get_special_flag_format {
	# special flag to format
	my $sflag = shift;
	if ($sflag eq "--last") {
		return "--max-count 1";
	}
}

# get resulting command that will be passed
# to the shell once processing is completed
sub get_result {
	my @command = undef;
	my @flags   = @_;
	my @options = ();
	my @sflags  = (
		"--first",
		"--func",
		"--last",
		"--lines",
		"--side-by-side"
	);
	# verify there aren't any conflicts before
	# assembling the shell command string
	if (&has_conflicts(@flags)) {
		die "$git_track_mutins_error_message";
	}
	# iterate over `@flags` array and take additional care
	# to handle the flag options that need special formatting
	foreach my $flag (@flags) {
		my $in_array = grep { $flag eq $_ } @sflags;
		if ($in_array) {
			$flag = &get_special_flag_format($flag);
		}
		push @options, $flag;
	}
	# join the arrays into a single string we can pass to `system`
	@command = join ' ', @git_log, @git_log_flags, @options, $filename;
	return @command;
}

# execute `git track` in the shell
sub git_track {
	my @command = shift;
	my $return  = shift;
	system @command;
	# unless explicitly told to do so,
	# exit the script once the `system`
	# command has ran and completed
	if (!defined $return) {
		exit;
	# otherwise, return the exit status code
	# that was emitted from the `system` call
	} else {
		$?;
	}
}

# determine if value is an integer of not
sub is_integer {
	my $value = shift;
	if ($value =~ /^\d+?$/) {
		return 1;
	} else {
		return 0;
	}
}

# verify `$filename` is a valid file before
# we start processing any additional input
if (! -e $filename) {
	die "Could not locate file '$filename'. Please verify the file exists and the path is valid";
}

# set the default diff view if `$git_log_default_diff`
# is defined in scope and contains a valid argument
if (defined $git_log_default_diff) {
	# get the correct flag option based on the flag given
	my $diff_view = &get_flag($git_log_default_diff);
	unshift @git_log_flags, $diff_view if defined $diff_view;
}

my @aflags = &get_flags(@argv);
my @result = &get_result(@aflags);

# execute `git track` command in the shell
git_track @result;
